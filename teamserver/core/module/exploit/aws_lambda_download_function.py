import botocore
import flask_mongoengine
from mongoengine import NotUniqueError, FieldDoesNotExist

from core.createSession.giveMeClient import giveMeClient
import sys
from core.database.models import AWSLambda
from flask_mongoengine import DoesNotExist

author = {
    "name": "gl4ssesbo1",
    "twitter": "https://twitter.com/gl4ssesbo1",
    "github": "https://github.com/gl4ssesbo1",
    "blog": "https://www.pepperclipp.com/"
}

needs_creds = True

variables = {
    "SERVICE": {
        "value": "lambda",
        "required": "true",
        "description": "The service that will be used to run the module. It cannot be changed."
    },
    "FUNCTION-NAME": {
        "value": "",
        "required": "true",
        "description": "The name, ARN or partial ARN of a Function"
    },
    "FUNCTION-VERSION": {
        "value": "",
        "required": "false",
        "description": "Specify a version or alias to get details about a published version of the function."
    }
}
description = "Get the source code of a specific function (and/or version) provided."

aws_command = "aws lambda get-function --function-name <my-function> -region <region> --profile <profile>"

def exploit(all_sessions, cred_prof, useragent, web_proxies, callstoprofile):
    functionname = variables['FUNCTION-NAME']['value']
    functionversion = variables['FUNCTION-VERSION']['value']

    lambdaProfile = giveMeClient(
        all_sessions,
        cred_prof,
        useragent,
        web_proxies,
        "lambda"
    )
    region = ""
    '''
    aws_lambda_function_name = db.StringField(required=True, unique=True)
    aws_lambda_function_role = db.StringField()
    aws_lambda_function_runtime = db.StringField()
    aws_lambda_function_description = db.StringField()
    aws_lambda_function_state = db.StringField()
    aws_lambda_function_handler = db.StringField()
    aws_lambda_function_arch = db.StringField()
    aws_lambda_function_repo_type = db.StringField()
    aws_lambda_function_location = db.StringField()
    '''

    # FuncTIonNaMEe

    try:
        if functionversion == "":
            response = lambdaProfile.get_function(
                FunctionName=functionname,
            )
        else:
            response = lambdaProfile.get_function(
                FunctionName=functionname,
                Qualifier=functionversion
            )

        key = f"{functionname}:{response['Configuration']['Version']}"
        region = lambdaProfile.meta.region_name
        lambda_json = {
            "aws_lambda_function_name": key,
            "aws_lambda_function_role": response['Configuration']['Role'],
            "aws_lambda_function_runtime": response['Configuration']['Runtime'],
            "aws_lambda_function_description": response['Configuration']['Description'],
            "aws_lambda_function_state": response['Configuration']['State'],
            "aws_lambda_function_handler": response['Configuration']['Handler'],
            "aws_lambda_function_repo_type": response['Configuration']['PackageType'],
            "aws_lambda_function_location": response['Code']['Location']
        }

        try:
            lambdaobj = AWSLambda.objects.get(aws_lambda_function_name=key)
            lambdaobj.modify(**lambda_json)
            lambdaobj.save()
            return {"URL": response['Code']['Location']}

        except flask_mongoengine.DoesNotExist:
            #AWSLambda.objects(**lambda_json).save()
            AWSLambda(**lambda_json).save()
            return {"URL": response['Code']['Location']}

        except Exception as e:
            if "AWSLambda matching query does not exist" in e:
                return {"error": "AWSLambda matching query does not exist".format(str(e))}, 500
            else:
                return {"error": "Error from module: {}".format(str(e))}, 500

    except botocore.exceptions.ClientError:
        return {"error": f"Error: {str(e)}"}

    except Exception as e:
        if "ResourceNotFoundException" in str(e):
            return {"error": f"Function {functionname} not found on region {region}"}
        return {"error": str(e)}
