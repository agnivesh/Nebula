import json
import os
import time

import botocore.exceptions
import sys

from core.createSession.giveMeClient import giveMeClient

author = {
    "name": "gl4ssesbo1",
    "twitter": "https://twitter.com/gl4ssesbo1",
    "github": "https://github.com/gl4ssesbo1",
    "blog": "https://www.pepperclipp.com/"
}

needs_creds = True

variables = {
    "SERVICE": {
        "value": "ssm",
        "required": "true",
        "description": "The service that will be used to run the module. It cannot be changed."
    },
    "INSTANCE-ID": {
        "value": "",
        "required": "false",
        "description": "The ID of the instance or several Instance IDs split by comma. If empty, DescribeInstances will be used to get a list of all Instances."
    },
    "INSTANCE-PLATFORM": {
        "value": "linux",
        "required": "true",
        "choices": ["linux", "windows"],
        "description": "The ID of the instance or several Instance IDs split by comma. Or use All. If set to All, DescribeInstances will be used to get a list of all Instances."
    },
    "COMMAND-FILE": {
        "value": "",
        "required": "false",
        "description": 'File path of a list of commands to be executed on the target instances. Either put this or COMMAND',
        "iswordlist": True,
        "wordlistvalue": [],

    },
    "PARAMETER-JSON": {
        "value": "",
        "required": "false",
        "description": "If you add this, don't add COMMAND or COMMAND-FILE. The parameters of the Document to run. You can call the GetDocument API to verify the document exists before attempting to start a session. Also, on directory client/tools on Nebula there are some parameter files for different Documents. If no document name is provided, a shell to the instance is launched by default."
    },
    "COMMENT": {
        "value": "",
        "required": "false",
        "description": "You can leave this empty, but adding a convincing comment will make it look more like a normal call, than a malicious one."
    },
    "TIMEOUT-SECONDS": {
        "value": "30",
        "required": "true",
        "description": "The time to wait for a command to run. If this time is reached and the command has not already started running, it will not run."
    },
    "OUTPUT-S3-BUCKET-NAME": {
        "value": "",
        "required": "false",
        "description": "The name of the S3 bucket where command execution responses should be stored."
    },
    "OUTPUT-S3-BUCKET-REGION": {
        "value": "",
        "required": "false",
        "description": "The region of the S3 bucket where command execution responses should be stored."
    },
    "OUTPUT-S3-BUCKET-PREFIX": {
        "value": "",
        "required": "false",
        "description": "The directory structure within the S3 bucket where the responses should be stored."
    }
}
description = "SendCommands to some InstanceIDs provided, split by comma, or a file of InstanceIDs." \
              "Also shows the output of the command if you want to." \
              "The APIs used are ssm:SendCommand and ssm:GetCommandInvocation."

aws_command = """
aws ssm send-command --document-name <Document Name> --instance-ids <instance ID> --profile <profile>
aws ssm get-command-invocation --command-id <command ID> --instance-id <instance ID> --profile <profile>
"""

calls = [
    "DescribeInstances",
    "SendCommand"
]
def startClient():
    print()
def sendSingleInstanceCommand(ssmProfile, instanceId, documentName, args):
    try:
        args['InstanceIds'] = [instanceId]
        args['DocumentName'] = documentName
        commandID = ssmProfile.send_command(
            **args
        )['Command']['CommandId']
        time.sleep(3)
        #print(commandID)

        response = ssmProfile.get_command_invocation(
            CommandId=commandID,
            InstanceId=instanceId
        )

        #print(response)

        while response['Status'] == "InProgress" or \
         response['Status'] == "Pending" or \
         response['Status'] == "Delayed":
            time.sleep(3)
            response = ssmProfile.get_command_invocation(
                CommandId=commandID,
                InstanceId=instanceId
            )



        return {
            "InstanceID": instanceId,
            "Status": f"Command was successful on Instance '{instanceId}'. {response['StatusDetails']}: {response['StandardOutputContent']}"
        }

    except ssmProfile.exceptions.InvalidDocument:
        return {
            "InstanceID": instanceId,
            "Status": f"The document provided is not valid or does not exist.'"
        }

    except ssmProfile.exceptions.TargetNotConnected:
        return {
            "InstanceID": instanceId,
            "Status": f"You cannot connect to the target. Either you have an internet problem, or the target might be shutdown/removed."
        }

    except Exception as e:
        return {
            "InstanceID": instanceId,
            "Status": f"Error on Instance '{instanceId}': {str(e)}"
        }
    #for instance in instanceList:

#def exploit(all_sessions, cred_prof, useragent, web_proxies, callstoprofile):
def exploit(profile, callstoprofile):
    try:
        instance_id = variables['INSTANCE-ID']['value']
        parameters = variables['PARAMETER-JSON']['value']
        command_array = variables['COMMAND-FILE']['wordlistvalue']
        timeout = variables['TIMEOUT-SECONDS']['value']
        outputs3name = variables['OUTPUT-S3-BUCKET-NAME']['value']
        outputs3region = variables['OUTPUT-S3-BUCKET-REGION']['value']
        outputs3prefix = variables['OUTPUT-S3-BUCKET-PREFIX']['value']
        instanceplatform = variables['INSTANCE-PLATFORM']['value']

        ssmProfile = profile

        """ec2Profile = giveMeClient(
            all_sessions,
            cred_prof,
            useragent,
            web_proxies,
            "ec2"
        )"""

        """ssmProfile = giveMeClient(
            all_sessions,
            cred_prof,
            useragent,
            web_proxies,
            "ssm"
        )"""

        if parameters == "":
            parameters = {
                "commands": command_array
            }

        params = {}
        args = {}
        linuxInstances = []
        windowsInstances = []
        allinstances = []
        if instance_id == "":
            if instance_id == "":
                try:
                    os.popen("mv ~/.aws/ ~/aws.old")
                    instanceReservations = json.loads(os.popen(f"aws ec2 describe-instances --region {ssmProfile.meta.region_name}").read()) #ec2Profile.describe_instances()['Reservations']
                    os.popen("mv ~/aws.old ~/.aws/")

                    for reservation in instanceReservations['Reservations']:
                        for instanceDict in reservation['Instances']:
                            allinstances.append(instanceDict)

                    if len(allinstances) == 0:
                        return {"error": "There are no instances used in the account"}

                    for instance in allinstances:
                        #print(instance)
                        #for ami in AMIImages:
                        #    if ami['ImageId'] == instance['ImageId']:
                        #        print("yes")
                        if instance['PlatformDetails'] == "Windows":
                            windowsInstances.append(instance['InstanceId'])

                        else:
                            linuxInstances.append(instance['InstanceId'])

                except botocore.exceptions.ClientError:
                    return {"error": "User has no access to DescribeInstances. Provide a list of InstanceIDs to "
                                     "continue."}
        else:
            if instanceplatform == "linux":
                linuxInstances = [instance_id]
            else:
                windowsInstances = [instance_id]

        if not timeout == "":
            try:
                args['TimeoutSeconds'] = int(timeout)
            except ValueError:
                return {"error": "TimeoutSeconds can only be an integer."}

        if not outputs3name == "":
            args['OutputS3BucketName'] = outputs3name

        if not outputs3region == "":
            args['OutputS3KeyRegion'] = outputs3region

        if not outputs3prefix == "":
            args['OutputS3KeyPrefix'] = outputs3prefix

        args['Parameters'] = parameters

        allinst = []
        for linstance in linuxInstances:
            allinst.append(sendSingleInstanceCommand(ssmProfile, linstance, "AWS-RunShellScript", args))

        for winstance in windowsInstances:
            allinst.append(sendSingleInstanceCommand(ssmProfile, winstance, "AWS-RunPowerShellScript", args))

        return {
            "InstanceID": allinst
        }
    except Exception as e:
        return {"error": str(e)}


